import{j as e,I as n,K as a,L as t,B as s,a as c}from"./javascript.min.js";function i(i){const r=e(i),o=n,l=["any","void","number","boolean","string","object","never","symbol","bigint","unknown"],d={beginKeywords:"namespace",end:/\{/,excludeEnd:!0,contains:[r.exports.CLASS_REFERENCE]},p={beginKeywords:"interface",end:/\{/,excludeEnd:!0,keywords:{keyword:"interface extends",built_in:l},contains:[r.exports.CLASS_REFERENCE]},b={$pattern:n,keyword:a.concat(["type","namespace","interface","public","private","protected","implements","declare","abstract","readonly","enum","override"]),literal:t,built_in:s.concat(l),"variable.language":c},m={className:"meta",begin:"@"+o},u=(e,n,a)=>{const t=e.contains.findIndex((e=>e.label===n));if(-1===t)throw new Error("can not find mode to replace");e.contains.splice(t,1,a)};Object.assign(r.keywords,b),r.exports.PARAMS_CONTAINS.push(m);const E=r.contains.find((e=>"attr"===e.className));r.exports.PARAMS_CONTAINS.push([r.exports.CLASS_REFERENCE,E]),r.contains=r.contains.concat([m,d,p]),u(r,"shebang",i.SHEBANG()),u(r,"use_strict",{className:"meta",relevance:10,begin:/^\s*['"]use strict['"]/});return r.contains.find((e=>"func.def"===e.label)).relevance=0,Object.assign(r,{name:"TypeScript",aliases:["ts","tsx","mts","cts"]}),r}export{i as default};
//# sourceMappingURL=typescript.map
