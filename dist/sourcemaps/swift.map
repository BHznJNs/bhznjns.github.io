{"version":3,"file":"swift.min.js","sources":["../../src/libs/highlight-es/lib/regex.js","../../src/libs/highlight-es/languages/lib/kws_swift.js","../../src/libs/highlight-es/languages/swift.js"],"sourcesContent":["/**\r\n * @param {string} value\r\n * @returns {RegExp}\r\n * */\r\nexport function escape(value) {\r\n  return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), 'm');\r\n}\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nexport function source(re) {\r\n  if (!re) return null;\r\n  if (typeof re === \"string\") return re;\r\n\r\n  return re.source;\r\n}\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nexport function lookahead(re) {\r\n  return concat('(?=', re, ')');\r\n}\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nexport function anyNumberOfTimes(re) {\r\n  return concat('(?:', re, ')*');\r\n}\r\n\r\n/**\r\n * @param {RegExp | string } re\r\n * @returns {string}\r\n */\r\nexport function optional(re) {\r\n  return concat('(?:', re, ')?');\r\n}\r\n\r\n/**\r\n * @param {...(RegExp | string) } args\r\n * @returns {string}\r\n */\r\nexport function concat(...args) {\r\n  const joined = args.map((x) => source(x)).join(\"\");\r\n  return joined;\r\n}\r\n\r\n/**\r\n * @param { Array<string | RegExp | Object> } args\r\n * @returns {object}\r\n */\r\nfunction stripOptionsFromArgs(args) {\r\n  const opts = args[args.length - 1];\r\n\r\n  if (typeof opts === 'object' && opts.constructor === Object) {\r\n    args.splice(args.length - 1, 1);\r\n    return opts;\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n\r\n/** @typedef { {capture?: boolean} } RegexEitherOptions */\r\n\r\n/**\r\n * Any of the passed expresssions may match\r\n *\r\n * Creates a huge this | this | that | that match\r\n * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\r\n * @returns {string}\r\n */\r\nexport function either(...args) {\r\n  /** @type { object & {capture?: boolean} }  */\r\n  const opts = stripOptionsFromArgs(args);\r\n  const joined = '('\r\n    + (opts.capture ? \"\" : \"?:\")\r\n    + args.map((x) => source(x)).join(\"|\") + \")\";\r\n  return joined;\r\n}\r\n\r\n/**\r\n * @param {RegExp | string} re\r\n * @returns {number}\r\n */\r\nexport function countMatchGroups(re) {\r\n  return (new RegExp(re.toString() + '|')).exec('').length - 1;\r\n}\r\n\r\n/**\r\n * Does lexeme start with a regular expression match at the beginning\r\n * @param {RegExp} re\r\n * @param {string} lexeme\r\n */\r\nexport function startsWith(re, lexeme) {\r\n  const match = re && re.exec(lexeme);\r\n  return match && match.index === 0;\r\n}\r\n\r\n// BACKREF_RE matches an open parenthesis or backreference. To avoid\r\n// an incorrect parse, it additionally matches the following:\r\n// - [...] elements, where the meaning of parentheses and escapes change\r\n// - other escape sequences, so we do not misparse escape sequences as\r\n//   interesting elements\r\n// - non-matching or lookahead parentheses, which do not capture. These\r\n//   follow the '(' with a '?'.\r\nconst BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\r\n\r\n// **INTERNAL** Not intended for outside usage\r\n// join logically computes regexps.join(separator), but fixes the\r\n// backreferences so they continue to match.\r\n// it also places each individual regular expression into it's own\r\n// match group, keeping track of the sequencing of those match groups\r\n// is currently an exercise for the caller. :-)\r\n/**\r\n * @param {(string | RegExp)[]} regexps\r\n * @param {{joinWith: string}} opts\r\n * @returns {string}\r\n */\r\nexport function _rewriteBackreferences(regexps, { joinWith }) {\r\n  let numCaptures = 0;\r\n\r\n  return regexps.map((regex) => {\r\n    numCaptures += 1;\r\n    const offset = numCaptures;\r\n    let re = source(regex);\r\n    let out = '';\r\n\r\n    while (re.length > 0) {\r\n      const match = BACKREF_RE.exec(re);\r\n      if (!match) {\r\n        out += re;\r\n        break;\r\n      }\r\n      out += re.substring(0, match.index);\r\n      re = re.substring(match.index + match[0].length);\r\n      if (match[0][0] === '\\\\' && match[1]) {\r\n        // Adjust the backreference.\r\n        out += '\\\\' + String(Number(match[1]) + offset);\r\n      } else {\r\n        out += match[0];\r\n        if (match[0] === '(') {\r\n          numCaptures++;\r\n        }\r\n      }\r\n    }\r\n    return out;\r\n  }).map(re => `(${re})`).join(joinWith);\r\n}\r\n","import {\r\n  concat,\r\n  either\r\n} from '../../lib/regex.js';\r\n\r\nexport const keywordWrapper = keyword => concat(\r\n  /\\b/,\r\n  keyword,\r\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\r\n);\r\n\r\n// Keywords that require a leading dot.\r\nexport const dotKeywords = [\r\n  'Protocol', // contextual\r\n  'Type' // contextual\r\n].map(keywordWrapper);\r\n\r\n// Keywords that may have a leading dot.\r\nexport const optionalDotKeywords = [\r\n  'init',\r\n  'self'\r\n].map(keywordWrapper);\r\n\r\n// should register as keyword, not type\r\nexport const keywordTypes = [\r\n  'Any',\r\n  'Self'\r\n];\r\n\r\n// Regular keywords and literals.\r\nexport const keywords = [\r\n  // strings below will be fed into the regular `keywords` engine while regex\r\n  // will result in additional modes being created to scan for those keywords to\r\n  // avoid conflicts with other rules\r\n  'actor',\r\n  'any', // contextual\r\n  'associatedtype',\r\n  'async',\r\n  'await',\r\n  /as\\?/, // operator\r\n  /as!/, // operator\r\n  'as', // operator\r\n  'borrowing', // contextual\r\n  'break',\r\n  'case',\r\n  'catch',\r\n  'class',\r\n  'consume', // contextual\r\n  'consuming', // contextual\r\n  'continue',\r\n  'convenience', // contextual\r\n  'copy', // contextual\r\n  'default',\r\n  'defer',\r\n  'deinit',\r\n  'didSet', // contextual\r\n  'distributed',\r\n  'do',\r\n  'dynamic', // contextual\r\n  'each',\r\n  'else',\r\n  'enum',\r\n  'extension',\r\n  'fallthrough',\r\n  /fileprivate\\(set\\)/,\r\n  'fileprivate',\r\n  'final', // contextual\r\n  'for',\r\n  'func',\r\n  'get', // contextual\r\n  'guard',\r\n  'if',\r\n  'import',\r\n  'indirect', // contextual\r\n  'infix', // contextual\r\n  /init\\?/,\r\n  /init!/,\r\n  'inout',\r\n  /internal\\(set\\)/,\r\n  'internal',\r\n  'in',\r\n  'is', // operator\r\n  'isolated', // contextual\r\n  'nonisolated', // contextual\r\n  'lazy', // contextual\r\n  'let',\r\n  'macro',\r\n  'mutating', // contextual\r\n  'nonmutating', // contextual\r\n  /open\\(set\\)/, // contextual\r\n  'open', // contextual\r\n  'operator',\r\n  'optional', // contextual\r\n  'override', // contextual\r\n  'postfix', // contextual\r\n  'precedencegroup',\r\n  'prefix', // contextual\r\n  /private\\(set\\)/,\r\n  'private',\r\n  'protocol',\r\n  /public\\(set\\)/,\r\n  'public',\r\n  'repeat',\r\n  'required', // contextual\r\n  'rethrows',\r\n  'return',\r\n  'set', // contextual\r\n  'some', // contextual\r\n  'static',\r\n  'struct',\r\n  'subscript',\r\n  'super',\r\n  'switch',\r\n  'throws',\r\n  'throw',\r\n  /try\\?/, // operator\r\n  /try!/, // operator\r\n  'try', // operator\r\n  'typealias',\r\n  /unowned\\(safe\\)/, // contextual\r\n  /unowned\\(unsafe\\)/, // contextual\r\n  'unowned', // contextual\r\n  'var',\r\n  'weak', // contextual\r\n  'where',\r\n  'while',\r\n  'willSet' // contextual\r\n];\r\n\r\n// NOTE: Contextual keywords are reserved only in specific contexts.\r\n// Ideally, these should be matched using modes to avoid false positives.\r\n\r\n// Literals.\r\nexport const literals = [\r\n  'false',\r\n  'nil',\r\n  'true'\r\n];\r\n\r\n// Keywords used in precedence groups.\r\nexport const precedencegroupKeywords = [\r\n  'assignment',\r\n  'associativity',\r\n  'higherThan',\r\n  'left',\r\n  'lowerThan',\r\n  'none',\r\n  'right'\r\n];\r\n\r\n// Keywords that start with a number sign (#).\r\n// #(un)available is handled separately.\r\nexport const numberSignKeywords = [\r\n  '#colorLiteral',\r\n  '#column',\r\n  '#dsohandle',\r\n  '#else',\r\n  '#elseif',\r\n  '#endif',\r\n  '#error',\r\n  '#file',\r\n  '#fileID',\r\n  '#fileLiteral',\r\n  '#filePath',\r\n  '#function',\r\n  '#if',\r\n  '#imageLiteral',\r\n  '#keyPath',\r\n  '#line',\r\n  '#selector',\r\n  '#sourceLocation',\r\n  '#warning'\r\n];\r\n\r\n// Global functions in the Standard Library.\r\nexport const builtIns = [\r\n  'abs',\r\n  'all',\r\n  'any',\r\n  'assert',\r\n  'assertionFailure',\r\n  'debugPrint',\r\n  'dump',\r\n  'fatalError',\r\n  'getVaList',\r\n  'isKnownUniquelyReferenced',\r\n  'max',\r\n  'min',\r\n  'numericCast',\r\n  'pointwiseMax',\r\n  'pointwiseMin',\r\n  'precondition',\r\n  'preconditionFailure',\r\n  'print',\r\n  'readLine',\r\n  'repeatElement',\r\n  'sequence',\r\n  'stride',\r\n  'swap',\r\n  'swift_unboxFromSwiftValueWithType',\r\n  'transcode',\r\n  'type',\r\n  'unsafeBitCast',\r\n  'unsafeDowncast',\r\n  'withExtendedLifetime',\r\n  'withUnsafeMutablePointer',\r\n  'withUnsafePointer',\r\n  'withVaList',\r\n  'withoutActuallyEscaping',\r\n  'zip'\r\n];\r\n\r\n// Valid first characters for operators.\r\nexport const operatorHead = either(\r\n  /[/=\\-+!*%<>&|^~?]/,\r\n  /[\\u00A1-\\u00A7]/,\r\n  /[\\u00A9\\u00AB]/,\r\n  /[\\u00AC\\u00AE]/,\r\n  /[\\u00B0\\u00B1]/,\r\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\r\n  /[\\u2016-\\u2017]/,\r\n  /[\\u2020-\\u2027]/,\r\n  /[\\u2030-\\u203E]/,\r\n  /[\\u2041-\\u2053]/,\r\n  /[\\u2055-\\u205E]/,\r\n  /[\\u2190-\\u23FF]/,\r\n  /[\\u2500-\\u2775]/,\r\n  /[\\u2794-\\u2BFF]/,\r\n  /[\\u2E00-\\u2E7F]/,\r\n  /[\\u3001-\\u3003]/,\r\n  /[\\u3008-\\u3020]/,\r\n  /[\\u3030]/\r\n);\r\n\r\n// Valid characters for operators.\r\nexport const operatorCharacter = either(\r\n  operatorHead,\r\n  /[\\u0300-\\u036F]/,\r\n  /[\\u1DC0-\\u1DFF]/,\r\n  /[\\u20D0-\\u20FF]/,\r\n  /[\\uFE00-\\uFE0F]/,\r\n  /[\\uFE20-\\uFE2F]/\r\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\r\n  // /[\\u{E0100}-\\u{E01EF}]/u\r\n);\r\n\r\n// Valid operator.\r\nexport const operator = concat(operatorHead, operatorCharacter, '*');\r\n\r\n// Valid first characters for identifiers.\r\nexport const identifierHead = either(\r\n  /[a-zA-Z_]/,\r\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\r\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\r\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\r\n  /[\\u1E00-\\u1FFF]/,\r\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\r\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\r\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\r\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\r\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\r\n  /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\r\n  // The following characters are also allowed, but the regexes aren't supported yet.\r\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\r\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\r\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\r\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\r\n);\r\n\r\n// Valid characters for identifiers.\r\nexport const identifierCharacter = either(\r\n  identifierHead,\r\n  /\\d/,\r\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\r\n);\r\n\r\n// Valid identifier.\r\nexport const identifier = concat(identifierHead, identifierCharacter, '*');\r\n\r\n// Valid type identifier.\r\nexport const typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\r\n\r\n// Built-in attributes, which are highlighted as keywords.\r\n// @available is handled separately.\r\n// https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes\r\nexport const keywordAttributes = [\r\n  'attached',\r\n  'autoclosure',\r\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\r\n  'discardableResult',\r\n  'dynamicCallable',\r\n  'dynamicMemberLookup',\r\n  'escaping',\r\n  'freestanding',\r\n  'frozen',\r\n  'GKInspectable',\r\n  'IBAction',\r\n  'IBDesignable',\r\n  'IBInspectable',\r\n  'IBOutlet',\r\n  'IBSegueAction',\r\n  'inlinable',\r\n  'main',\r\n  'nonobjc',\r\n  'NSApplicationMain',\r\n  'NSCopying',\r\n  'NSManaged',\r\n  concat(/objc\\(/, identifier, /\\)/),\r\n  'objc',\r\n  'objcMembers',\r\n  'propertyWrapper',\r\n  'requires_stored_property_inits',\r\n  'resultBuilder',\r\n  'Sendable',\r\n  'testable',\r\n  'UIApplicationMain',\r\n  'unchecked',\r\n  'unknown',\r\n  'usableFromInline',\r\n  'warn_unqualified_access'\r\n];\r\n\r\n// Contextual keywords used in @available and #(un)available.\r\nexport const availabilityKeywords = [\r\n  'iOS',\r\n  'iOSApplicationExtension',\r\n  'macOS',\r\n  'macOSApplicationExtension',\r\n  'macCatalyst',\r\n  'macCatalystApplicationExtension',\r\n  'watchOS',\r\n  'watchOSApplicationExtension',\r\n  'tvOS',\r\n  'tvOSApplicationExtension',\r\n  'swift'\r\n];\r\n","/*\r\nLanguage: Swift\r\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\r\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\r\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\r\nWebsite: https://swift.org\r\nCategory: common, system\r\n*/\r\n\r\nimport * as Swift from './lib/kws_swift.js';\r\nimport {\r\n  concat,\r\n  either,\r\n  lookahead\r\n} from '../lib/regex.js';\r\n\r\n/** @type LanguageFn */\r\nexport default function(hljs) {\r\n  const WHITESPACE = {\r\n    match: /\\s+/,\r\n    relevance: 0\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\r\n  const BLOCK_COMMENT = hljs.COMMENT(\r\n    '/\\\\*',\r\n    '\\\\*/',\r\n    { contains: [ 'self' ] }\r\n  );\r\n  const COMMENTS = [\r\n    hljs.C_LINE_COMMENT_MODE,\r\n    BLOCK_COMMENT\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\r\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\r\n  const DOT_KEYWORD = {\r\n    match: [\r\n      /\\./,\r\n      either(...Swift.dotKeywords, ...Swift.optionalDotKeywords)\r\n    ],\r\n    className: { 2: \"keyword\" }\r\n  };\r\n  const KEYWORD_GUARD = {\r\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\r\n    match: concat(/\\./, either(...Swift.keywords)),\r\n    relevance: 0\r\n  };\r\n  const PLAIN_KEYWORDS = Swift.keywords\r\n    .filter(kw => typeof kw === 'string')\r\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\r\n  const REGEX_KEYWORDS = Swift.keywords\r\n    .filter(kw => typeof kw !== 'string') // find regex\r\n    .concat(Swift.keywordTypes)\r\n    .map(Swift.keywordWrapper);\r\n  const KEYWORD = { variants: [\r\n    {\r\n      className: 'keyword',\r\n      match: either(...REGEX_KEYWORDS, ...Swift.optionalDotKeywords)\r\n    }\r\n  ] };\r\n  // find all the regular keywords\r\n  const KEYWORDS = {\r\n    $pattern: either(\r\n      /\\b\\w+/, // regular keywords\r\n      /#\\w+/ // number keywords\r\n    ),\r\n    keyword: PLAIN_KEYWORDS\r\n      .concat(Swift.numberSignKeywords),\r\n    literal: Swift.literals\r\n  };\r\n  const KEYWORD_MODES = [\r\n    DOT_KEYWORD,\r\n    KEYWORD_GUARD,\r\n    KEYWORD\r\n  ];\r\n\r\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\r\n  const BUILT_IN_GUARD = {\r\n    // Consume .built_in to prevent highlighting properties and methods.\r\n    match: concat(/\\./, either(...Swift.builtIns)),\r\n    relevance: 0\r\n  };\r\n  const BUILT_IN = {\r\n    className: 'built_in',\r\n    match: concat(/\\b/, either(...Swift.builtIns), /(?=\\()/)\r\n  };\r\n  const BUILT_INS = [\r\n    BUILT_IN_GUARD,\r\n    BUILT_IN\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\r\n  const OPERATOR_GUARD = {\r\n    // Prevent -> from being highlighting as an operator.\r\n    match: /->/,\r\n    relevance: 0\r\n  };\r\n  const OPERATOR = {\r\n    className: 'operator',\r\n    relevance: 0,\r\n    variants: [\r\n      { match: Swift.operator },\r\n      {\r\n        // dot-operator: only operators that start with a dot are allowed to use dots as\r\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\r\n        // characters that may also include dots.\r\n        match: `\\\\.(\\\\.|${Swift.operatorCharacter})+` }\r\n    ]\r\n  };\r\n  const OPERATORS = [\r\n    OPERATOR_GUARD,\r\n    OPERATOR\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\r\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\r\n  const decimalDigits = '([0-9]_*)+';\r\n  const hexDigits = '([0-9a-fA-F]_*)+';\r\n  const NUMBER = {\r\n    className: 'number',\r\n    relevance: 0,\r\n    variants: [\r\n      // decimal floating-point-literal (subsumes decimal-literal)\r\n      { match: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b` },\r\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\r\n      { match: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b` },\r\n      // octal-literal\r\n      { match: /\\b0o([0-7]_*)+\\b/ },\r\n      // binary-literal\r\n      { match: /\\b0b([01]_*)+\\b/ }\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\r\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    variants: [\r\n      { match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/) },\r\n      { match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/) }\r\n    ]\r\n  });\r\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\r\n  });\r\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\r\n    className: 'subst',\r\n    label: \"interpol\",\r\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\r\n    end: /\\)/\r\n  });\r\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\r\n    begin: concat(rawDelimiter, /\"\"\"/),\r\n    end: concat(/\"\"\"/, rawDelimiter),\r\n    contains: [\r\n      ESCAPED_CHARACTER(rawDelimiter),\r\n      ESCAPED_NEWLINE(rawDelimiter),\r\n      INTERPOLATION(rawDelimiter)\r\n    ]\r\n  });\r\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\r\n    begin: concat(rawDelimiter, /\"/),\r\n    end: concat(/\"/, rawDelimiter),\r\n    contains: [\r\n      ESCAPED_CHARACTER(rawDelimiter),\r\n      INTERPOLATION(rawDelimiter)\r\n    ]\r\n  });\r\n  const STRING = {\r\n    className: 'string',\r\n    variants: [\r\n      MULTILINE_STRING(),\r\n      MULTILINE_STRING(\"#\"),\r\n      MULTILINE_STRING(\"##\"),\r\n      MULTILINE_STRING(\"###\"),\r\n      SINGLE_LINE_STRING(),\r\n      SINGLE_LINE_STRING(\"#\"),\r\n      SINGLE_LINE_STRING(\"##\"),\r\n      SINGLE_LINE_STRING(\"###\")\r\n    ]\r\n  };\r\n\r\n  const REGEXP_CONTENTS = [\r\n    hljs.BACKSLASH_ESCAPE,\r\n    {\r\n      begin: /\\[/,\r\n      end: /\\]/,\r\n      relevance: 0,\r\n      contains: [ hljs.BACKSLASH_ESCAPE ]\r\n    }\r\n  ];\r\n\r\n  const BARE_REGEXP_LITERAL = {\r\n    begin: /\\/[^\\s](?=[^/\\n]*\\/)/,\r\n    end: /\\//,\r\n    contains: REGEXP_CONTENTS\r\n  };\r\n\r\n  const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {\r\n    const begin = concat(rawDelimiter, /\\//);\r\n    const end = concat(/\\//, rawDelimiter);\r\n    return {\r\n      begin,\r\n      end,\r\n      contains: [\r\n        ...REGEXP_CONTENTS,\r\n        {\r\n          scope: \"comment\",\r\n          begin: `#(?!.*${end})`,\r\n          end: /$/,\r\n        },\r\n      ],\r\n    };\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/#Regular-Expression-Literals\r\n  const REGEXP = {\r\n    scope: \"regexp\",\r\n    variants: [\r\n      EXTENDED_REGEXP_LITERAL('###'),\r\n      EXTENDED_REGEXP_LITERAL('##'),\r\n      EXTENDED_REGEXP_LITERAL('#'),\r\n      BARE_REGEXP_LITERAL\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\r\n  const QUOTED_IDENTIFIER = { match: concat(/`/, Swift.identifier, /`/) };\r\n  const IMPLICIT_PARAMETER = {\r\n    className: 'variable',\r\n    match: /\\$\\d+/\r\n  };\r\n  const PROPERTY_WRAPPER_PROJECTION = {\r\n    className: 'variable',\r\n    match: `\\\\$${Swift.identifierCharacter}+`\r\n  };\r\n  const IDENTIFIERS = [\r\n    QUOTED_IDENTIFIER,\r\n    IMPLICIT_PARAMETER,\r\n    PROPERTY_WRAPPER_PROJECTION\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\r\n  const AVAILABLE_ATTRIBUTE = {\r\n    match: /(@|#(un)?)available/,\r\n    scope: 'keyword',\r\n    starts: { contains: [\r\n      {\r\n        begin: /\\(/,\r\n        end: /\\)/,\r\n        keywords: Swift.availabilityKeywords,\r\n        contains: [\r\n          ...OPERATORS,\r\n          NUMBER,\r\n          STRING\r\n        ]\r\n      }\r\n    ] }\r\n  };\r\n  const KEYWORD_ATTRIBUTE = {\r\n    scope: 'keyword',\r\n    match: concat(/@/, either(...Swift.keywordAttributes))\r\n  };\r\n  const USER_DEFINED_ATTRIBUTE = {\r\n    scope: 'meta',\r\n    match: concat(/@/, Swift.identifier)\r\n  };\r\n  const ATTRIBUTES = [\r\n    AVAILABLE_ATTRIBUTE,\r\n    KEYWORD_ATTRIBUTE,\r\n    USER_DEFINED_ATTRIBUTE\r\n  ];\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\r\n  const TYPE = {\r\n    match: lookahead(/\\b[A-Z]/),\r\n    relevance: 0,\r\n    contains: [\r\n      { // Common Apple frameworks, for relevance boost\r\n        className: 'type',\r\n        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Swift.identifierCharacter, '+')\r\n      },\r\n      { // Type identifier\r\n        className: 'type',\r\n        match: Swift.typeIdentifier,\r\n        relevance: 0\r\n      },\r\n      { // Optional type\r\n        match: /[?!]+/,\r\n        relevance: 0\r\n      },\r\n      { // Variadic parameter\r\n        match: /\\.\\.\\./,\r\n        relevance: 0\r\n      },\r\n      { // Protocol composition\r\n        match: concat(/\\s+&\\s+/, lookahead(Swift.typeIdentifier)),\r\n        relevance: 0\r\n      }\r\n    ]\r\n  };\r\n  const GENERIC_ARGUMENTS = {\r\n    begin: /</,\r\n    end: />/,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      ...COMMENTS,\r\n      ...KEYWORD_MODES,\r\n      ...ATTRIBUTES,\r\n      OPERATOR_GUARD,\r\n      TYPE\r\n    ]\r\n  };\r\n  TYPE.contains.push(GENERIC_ARGUMENTS);\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\r\n  // Prevents element names from being highlighted as keywords.\r\n  const TUPLE_ELEMENT_NAME = {\r\n    match: concat(Swift.identifier, /\\s*:/),\r\n    keywords: \"_|0\",\r\n    relevance: 0\r\n  };\r\n  // Matches tuples as well as the parameter list of a function type.\r\n  const TUPLE = {\r\n    begin: /\\(/,\r\n    end: /\\)/,\r\n    relevance: 0,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      'self',\r\n      TUPLE_ELEMENT_NAME,\r\n      ...COMMENTS,\r\n      REGEXP,\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS,\r\n      ...ATTRIBUTES,\r\n      TYPE\r\n    ]\r\n  };\r\n\r\n  const GENERIC_PARAMETERS = {\r\n    begin: /</,\r\n    end: />/,\r\n    keywords: 'repeat each',\r\n    contains: [\r\n      ...COMMENTS,\r\n      TYPE\r\n    ]\r\n  };\r\n  const FUNCTION_PARAMETER_NAME = {\r\n    begin: either(\r\n      lookahead(concat(Swift.identifier, /\\s*:/)),\r\n      lookahead(concat(Swift.identifier, /\\s+/, Swift.identifier, /\\s*:/))\r\n    ),\r\n    end: /:/,\r\n    relevance: 0,\r\n    contains: [\r\n      {\r\n        className: 'keyword',\r\n        match: /\\b_\\b/\r\n      },\r\n      {\r\n        className: 'params',\r\n        match: Swift.identifier\r\n      }\r\n    ]\r\n  };\r\n  const FUNCTION_PARAMETERS = {\r\n    begin: /\\(/,\r\n    end: /\\)/,\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      FUNCTION_PARAMETER_NAME,\r\n      ...COMMENTS,\r\n      ...KEYWORD_MODES,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...ATTRIBUTES,\r\n      TYPE,\r\n      TUPLE\r\n    ],\r\n    endsParent: true,\r\n    illegal: /[\"']/\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\r\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations/#Macro-Declaration\r\n  const FUNCTION_OR_MACRO = {\r\n    match: [\r\n      /(func|macro)/,\r\n      /\\s+/,\r\n      either(QUOTED_IDENTIFIER.match, Swift.identifier, Swift.operator)\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title.function\"\r\n    },\r\n    contains: [\r\n      GENERIC_PARAMETERS,\r\n      FUNCTION_PARAMETERS,\r\n      WHITESPACE\r\n    ],\r\n    illegal: [\r\n      /\\[/,\r\n      /%/\r\n    ]\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\r\n  const INIT_SUBSCRIPT = {\r\n    match: [\r\n      /\\b(?:subscript|init[?!]?)/,\r\n      /\\s*(?=[<(])/,\r\n    ],\r\n    className: { 1: \"keyword\" },\r\n    contains: [\r\n      GENERIC_PARAMETERS,\r\n      FUNCTION_PARAMETERS,\r\n      WHITESPACE\r\n    ],\r\n    illegal: /\\[|%/\r\n  };\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\r\n  const OPERATOR_DECLARATION = {\r\n    match: [\r\n      /operator/,\r\n      /\\s+/,\r\n      Swift.operator\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title\"\r\n    }\r\n  };\r\n\r\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\r\n  const PRECEDENCEGROUP = {\r\n    begin: [\r\n      /precedencegroup/,\r\n      /\\s+/,\r\n      Swift.typeIdentifier\r\n    ],\r\n    className: {\r\n      1: \"keyword\",\r\n      3: \"title\"\r\n    },\r\n    contains: [ TYPE ],\r\n    keywords: [\r\n      ...Swift.precedencegroupKeywords,\r\n      ...Swift.literals\r\n    ],\r\n    end: /}/\r\n  };\r\n\r\n  // Add supported submodes to string interpolation.\r\n  for (const variant of STRING.variants) {\r\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\r\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\r\n    interpolation.keywords = KEYWORDS;\r\n    const submodes = [\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS\r\n    ];\r\n    interpolation.contains = [\r\n      ...submodes,\r\n      {\r\n        begin: /\\(/,\r\n        end: /\\)/,\r\n        contains: [\r\n          'self',\r\n          ...submodes\r\n        ]\r\n      }\r\n    ];\r\n  }\r\n\r\n  return {\r\n    name: 'Swift',\r\n    keywords: KEYWORDS,\r\n    contains: [\r\n      ...COMMENTS,\r\n      FUNCTION_OR_MACRO,\r\n      INIT_SUBSCRIPT,\r\n      {\r\n        beginKeywords: 'struct protocol class extension enum actor',\r\n        end: '\\\\{',\r\n        excludeEnd: true,\r\n        keywords: KEYWORDS,\r\n        contains: [\r\n          hljs.inherit(hljs.TITLE_MODE, {\r\n            className: \"title.class\",\r\n            begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\r\n          }),\r\n          ...KEYWORD_MODES\r\n        ]\r\n      },\r\n      OPERATOR_DECLARATION,\r\n      PRECEDENCEGROUP,\r\n      {\r\n        beginKeywords: 'import',\r\n        end: /$/,\r\n        contains: [ ...COMMENTS ],\r\n        relevance: 0\r\n      },\r\n      REGEXP,\r\n      ...KEYWORD_MODES,\r\n      ...BUILT_INS,\r\n      ...OPERATORS,\r\n      NUMBER,\r\n      STRING,\r\n      ...IDENTIFIERS,\r\n      ...ATTRIBUTES,\r\n      TYPE,\r\n      TUPLE\r\n    ]\r\n  };\r\n}\r\n"],"names":["source","re","lookahead","concat","args","map","x","join","either","opts","length","constructor","Object","splice","stripOptionsFromArgs","capture","keywordWrapper","keyword","test","dotKeywords","optionalDotKeywords","keywordTypes","keywords","literals","precedencegroupKeywords","numberSignKeywords","builtIns","operatorHead","operatorCharacter","operator","identifierHead","identifierCharacter","identifier","typeIdentifier","keywordAttributes","availabilityKeywords","swift","hljs","WHITESPACE","match","relevance","BLOCK_COMMENT","COMMENT","contains","COMMENTS","C_LINE_COMMENT_MODE","DOT_KEYWORD","Swift.dotKeywords","Swift.optionalDotKeywords","className","KEYWORD_GUARD","Swift.keywords","PLAIN_KEYWORDS","filter","kw","KEYWORD","variants","Swift.keywordTypes","Swift.keywordWrapper","KEYWORDS","$pattern","Swift.numberSignKeywords","literal","Swift.literals","KEYWORD_MODES","BUILT_INS","Swift.builtIns","OPERATOR_GUARD","OPERATORS","Swift.operator","Swift.operatorCharacter","decimalDigits","hexDigits","NUMBER","ESCAPED_CHARACTER","rawDelimiter","ESCAPED_NEWLINE","INTERPOLATION","label","begin","end","MULTILINE_STRING","SINGLE_LINE_STRING","STRING","REGEXP_CONTENTS","BACKSLASH_ESCAPE","BARE_REGEXP_LITERAL","EXTENDED_REGEXP_LITERAL","scope","REGEXP","QUOTED_IDENTIFIER","Swift.identifier","IDENTIFIERS","Swift.identifierCharacter","ATTRIBUTES","starts","Swift.availabilityKeywords","Swift.keywordAttributes","TYPE","Swift.typeIdentifier","GENERIC_ARGUMENTS","push","TUPLE","GENERIC_PARAMETERS","FUNCTION_PARAMETERS","endsParent","illegal","FUNCTION_OR_MACRO","INIT_SUBSCRIPT","OPERATOR_DECLARATION","PRECEDENCEGROUP","Swift.precedencegroupKeywords","variant","interpolation","find","mode","submodes","name","beginKeywords","excludeEnd","inherit","TITLE_MODE"],"mappings":"AAYO,SAASA,EAAOC,GACrB,OAAKA,EACa,iBAAPA,EAAwBA,EAE5BA,EAAGD,OAHM,IAIlB,CAMO,SAASE,EAAUD,GACxB,OAAOE,EAAO,MAAOF,EAAI,IAC3B,CAsBO,SAASE,KAAUC,GAExB,OADeA,EAAKC,KAAKC,GAAMN,EAAOM,KAAIC,KAAK,GAEjD,CA0BO,SAASC,KAAUJ,GAExB,MAAMK,EAtBR,SAA8BL,GAC5B,MAAMK,EAAOL,EAAKA,EAAKM,OAAS,GAEhC,MAAoB,iBAATD,GAAqBA,EAAKE,cAAgBC,QACnDR,EAAKS,OAAOT,EAAKM,OAAS,EAAG,GACtBD,GAEA,EAEX,CAaeK,CAAqBV,GAIlC,MAHe,KACVK,EAAKM,QAAU,GAAK,MACrBX,EAAKC,KAAKC,GAAMN,EAAOM,KAAIC,KAAK,KAAO,GAE7C,CC9EO,MAAMS,EAAiBC,GAAWd,EACvC,KACAc,EACA,MAAMC,KAAKD,GAAW,KAAO,MAIlBE,EAAc,CACzB,WACA,QACAd,IAAIW,GAGOI,EAAsB,CACjC,OACA,QACAf,IAAIW,GAGOK,EAAe,CAC1B,MACA,QAIWC,EAAW,CAItB,QACA,MACA,iBACA,QACA,QACA,OACA,MACA,KACA,YACA,QACA,OACA,QACA,QACA,UACA,YACA,WACA,cACA,OACA,UACA,QACA,SACA,SACA,cACA,KACA,UACA,OACA,OACA,OACA,YACA,cACA,qBACA,cACA,QACA,MACA,OACA,MACA,QACA,KACA,SACA,WACA,QACA,SACA,QACA,QACA,kBACA,WACA,KACA,KACA,WACA,cACA,OACA,MACA,QACA,WACA,cACA,cACA,OACA,WACA,WACA,WACA,UACA,kBACA,SACA,iBACA,UACA,WACA,gBACA,SACA,SACA,WACA,WACA,SACA,MACA,OACA,SACA,SACA,YACA,QACA,SACA,SACA,QACA,QACA,OACA,MACA,YACA,kBACA,oBACA,UACA,MACA,OACA,QACA,QACA,WAOWC,EAAW,CACtB,QACA,MACA,QAIWC,EAA0B,CACrC,aACA,gBACA,aACA,OACA,YACA,OACA,SAKWC,EAAqB,CAChC,gBACA,UACA,aACA,QACA,UACA,SACA,SACA,QACA,UACA,eACA,YACA,YACA,MACA,gBACA,WACA,QACA,YACA,kBACA,YAIWC,EAAW,CACtB,MACA,MACA,MACA,SACA,mBACA,aACA,OACA,aACA,YACA,4BACA,MACA,MACA,cACA,eACA,eACA,eACA,sBACA,QACA,WACA,gBACA,WACA,SACA,OACA,oCACA,YACA,OACA,gBACA,iBACA,uBACA,2BACA,oBACA,aACA,0BACA,OAIWC,EAAenB,EAC1B,oBACA,kBACA,iBACA,iBACA,iBACA,mCACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,YAIWoB,EAAoBpB,EAC/BmB,EACA,kBACA,kBACA,kBACA,kBACA,mBAMWE,EAAW1B,EAAOwB,EAAcC,EAAmB,KAGnDE,EAAiBtB,EAC5B,YACA,uDACA,yDACA,yDACA,kBACA,+DACA,yDACA,+BACA,yDACA,yDACA,gCASWuB,EAAsBvB,EACjCsB,EACA,KACA,0DAIWE,EAAa7B,EAAO2B,EAAgBC,EAAqB,KAGzDE,EAAiB9B,EAAO,QAAS4B,EAAqB,KAKtDG,EAAoB,CAC/B,WACA,cACA/B,EAAO,eAAgBK,EAAO,QAAS,QAAS,KAAM,MACtD,oBACA,kBACA,sBACA,WACA,eACA,SACA,gBACA,WACA,eACA,gBACA,WACA,gBACA,YACA,OACA,UACA,oBACA,YACA,YACAL,EAAO,SAAU6B,EAAY,MAC7B,OACA,cACA,kBACA,iCACA,gBACA,WACA,WACA,oBACA,YACA,UACA,mBACA,2BAIWG,EAAuB,CAClC,MACA,0BACA,QACA,4BACA,cACA,kCACA,UACA,8BACA,OACA,2BACA,SC7Ta,SAAQC,EAACC,GACtB,MAAMC,EAAa,CACjBC,MAAO,MACPC,UAAW,GAGPC,EAAgBJ,EAAKK,QACzB,OACA,OACA,CAAEC,SAAU,CAAE,UAEVC,EAAW,CACfP,EAAKQ,oBACLJ,GAKIK,EAAc,CAClBP,MAAO,CACL,KACA/B,KAAUuC,KAAsBC,IAElCC,UAAW,CAAE,E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"}