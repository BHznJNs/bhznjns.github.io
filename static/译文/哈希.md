# 哈希

``2023/9/15``

原文链接：[Hashing](https://samwho.dev/hashing/)

- - -

作为一个程序员，你几乎每天都会使用哈希函数。哈希函数被用在数据库中优化数据查询，也被用于一些数据结构以优化性能，更可以用于安全领域来保障数据安全。你所使用的几乎每个技术都会以某种方式使用哈希。

哈希函数是非常基础的，它无处不在。

但，什么是哈希函数，它是如何运作的？

在本篇文章中，我们会向你揭晓哈希函数的运作。我们会从最简单的哈希函数开始，然后学习对哈希函数的测试，最后我们会聚焦于哈希函数的实际应用：哈希表。

- - -

## 什么是哈希函数？

哈希函数是一种接受一个输入（通常是一个字符串），根据这个输入返回一串数字的函数。如果你多次以同一参数调用哈希函数，它会返回同一串数字，并且这串返回的数字必定在预期的范围内。这里的范围取决于哈希函数的实现，有的哈希函数使用 32 位整型（0 到 四十亿），其它的可能会更大。

让我们使用 JavaScript 写一个伪哈希函数，它看起来应该像这样：

```javascript
function hash(input) {
  return 0;
}
```

即使不知道这个哈希函数应该如何使用，但它肯定不是无用的。接下来让我们看看一个好的哈希函数如何编写，在这之后，我们会探寻哈希函数在哈希表中的使用。

## 怎样的哈希函数更好？

由于函数的输入可以是任何字符串，但返回的数字则是在一定范围内的，这就导致两个不同的输入可能导致相同的输出，这被称为“哈希碰撞”。而一个好的哈希函数应该应可能的减少哈希碰撞的产生。

完全阻止哈希碰撞的产生是不可能的。如果我们编写一个返回值范围在 0 到 7 的哈希函数，然后给予它九个不同的输入，我们会发现至少一次哈希碰撞。

```javascript
hash("to")         == 3
hash("the")        == 2
hash("café")       == 0
hash("de")         == 6
hash("versailles") == 4
hash("for")        == 5
hash("coffee")     == 0
hash("we")         == 7
hash("had")        == 1
```

上述这些输出值来自 8 的模数。无论哪 9 个数作为输入，返回值只会是 0 到 7 这 8 个数也因此，哈希碰撞是不可避免的。而我们的目标就是使碰撞尽可能地减少。

为了可视化哈希碰撞，我使用了一个网格。网格中的每一个格子都用来表示哈希函数输出的一个数。这里是一个 8x2 的网格（见原文）。点击网格以进行示例哈希函数输入的累加，并且你可以看到我们将其映射进网格的格子中。观察当输入值大于网格数量时会发生什么。

![图示](.哈希/Screenshot%20Hashing1.png)

每一次我们计算一个值的哈希，我们都让其相应的方格的颜色变深。这个方法创造了一个简单的方式让我们来观察一个哈希函数是如何阻止哈希碰撞的。我们在探索的是更好地让结果均匀分布到每一个方格中的方法。通过这个方法我们会发现某个不足够可用的哈希函数。

> 文中提到，当一个哈希函数对于两个不同的输入输出相同的值的情况称为哈希碰撞。
> 但如果我们的哈希函数的输出值在一个非常大的范围内，我们再将那些范围映射到一个小网格中，这不就是在本无碰撞的网格中创造哈希碰撞吗？
> 在前面的 8x2 网格中，1 和 17 都被映射到第二个网格中。

这是对的，我们正在我们的网格中创造“伪碰撞”。这没什么，因为即使是对于最好的哈希函数也会出现哈希碰撞。如果我们有一个常常出现碰撞的哈希函数，那会变得很明显。

让我们创建一个更大的网格并且用这个网格表示 1000 个随机生成的字符串。你可以点击这个网格（见原文）以计算新的随机输入的集合的哈希，这个网格会通过动画展示每一个输入的哈希计算结果并体现在网格中。

![图示](.哈希/Screenshot%20Hashing2.png)

这些值很好地被平均分配了，因为使用了一个广为人知的哈希函数 murmur3。这一哈希函数因其高性能和良好的分配性被广泛运用。

如果我们使用了一个不好的哈希函数，我们的网格会是什么样？

```javascript
function hash(input) {
  let hash = 0;
  for (let c of input) {
    hash += c.charCodeAt(0);
  }
  return hash % 1000000;
}
```

这个哈希函数遍历输入的字符串并且计算求和每一个字符对于的数值。通过取模运算符 ``%`` 来将结果限制在 0 到 1000000 之间。我们可以把这个哈希函数称作 ``stringSum``。

这个网格是 1000 个随机生成的字符串哈希运算形成的。

![图例](.哈希/Screenshot%20Hashing3.png)

这似乎与 murmur3 产生的效果差不多。

有个问题，这些输入的字符串是随机产生的。让我们看看对于固定的字符串：从 1 到 1000 的数字转化成的字符串，这两个方法（murmur3 和 stringSum）的表现如何。

![图例](.哈希/Screenshot%20Hashing4.png)

现在问题明晰了。当输入固定时，stringSum 的结果呈现出一个模式；而我们的 murmur3 网格，则看起来和使用随机值时相同。

如果我们对使用率前 1000 的英语进行哈希运算，结果如下：

![图例](.哈希/Screenshot%20Hashing5.png)

这张图不是很明显。
