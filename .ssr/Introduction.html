<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="color-scheme" content="light dark">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction</title>
<link rel="shortcut icon" href="./dist/imgs/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="./dist/style.min.css">
</head>
<body>
<script>
const darkModeMediaQuery = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)")
const darkModeSwitcher = () => {
    const isDarkMode = darkModeMediaQuery.matches
    document.body.classList.toggle("dark" ,  isDarkMode)
    document.body.classList.toggle("light", !isDarkMode)
}
if (darkModeMediaQuery) {
    darkModeMediaQuery.addListener(darkModeSwitcher)
    darkModeSwitcher()
}
</script>
<nav>
    <a
    id="homepage"
    class="icon-btn underline-side left"
    href="../"
    onclick="globalThis.__CurrentPage__=1"
>
    <img src="../dist/imgs/homepage.svg" alt="主页">
    <span class="underline-target">主页</span>
</a>
    <span><a
    id="rss-icon"
    class="icon-btn"
    href="../user/rss.xml"
    title="RSS 订阅"
>
    <img
        src="../dist/imgs/rss.svg"
        alt="RSS 订阅"
    >
</a><span>
    <span
        id="light-btn"
        class="icon-btn"
        role="button"
        tabindex="0"
        title="亮色模式"
        onclick="document.body.classList.remove('dark'); document.body.classList.add('light')"
    >
        <img
            src="../dist/imgs/sun.svg"
            alt="亮色模式图标"
        >
    </span>
    <span
        id="dark-btn"
        class="icon-btn"
        role="button"
        tabindex="0"
        title="黑暗模式"
        onclick="document.body.classList.add('dark'); document.body.classList.remove('light')"
    >
        <img
            src="../dist/imgs/moon.svg"
            alt="黑暗模式图标"
        >
    </span>
</span></span>
</nav>
<article>
<h1>Introduction</h1><h2>为什么要使用数据库？</h2><p>如果使用普通的文件文件存储数据，以 CSV 文件格式为例，</p><ul><li>要读取某一特定条目的时间复杂度为 <code>O(n)</code></li><li>数据间没有关联，如果需要删除一条数据，如一个用户，无法同时删除与该用户有关的数据</li><li>CSV 读写不具备数据合法性校验的功能，如一条数据表示年份，但是它实际可以存储任意的字符串。</li><li>并发支持</li><li>...</li></ul><h2>Database Management System (DBMS)</h2><p>A software pieces that allow you to store, analyze and manipulate data in a database. </p><ul><li>make sure your data is safe</li></ul><h3>Data Models</h3><p>A <i>data model</i> is a collection of concepts for <strong>describing the data in a database</strong>.</p><p>A <i>schema</i> is a description of a particular collection of data with a given data model.</p><p>Most:</p><ul><li>Relational</li></ul><p>NoSQL:</p><ul><li>Key / value</li><li>Graph</li><li>Document / Object</li><li>Wide-Column / Column-family</li></ul><p>Machine Learning:</p><ul><li>Array / Matrix/ Vectors</li></ul><p>Obsolete / Legacy:</p><ul><li>Hierarchical</li><li>Network</li><li>Multi-Value</li></ul><hr><h2>Relational Model</h2><p>Key tenets:</p><ul><li>Store database in simple data structures (relations)</li><li><ruby data-notation="Physical storage left up to the DBMS implementation">实际的数据存储由数据库系统实现，脱离数据模型<rp>(</rp>,<rt>Physical storage left up to the DBMS implementation</rt>,<rp>)</rp></ruby></li><li><ruby data-notation="Access data through high-level language, DBMS figureout best execution strategy">数据访问使用高级语言，数据库系统负责保证性能<rp>(</rp>,<rt>Access data through high-level language, DBMS figureout best execution strategy</rt>,<rp>)</rp></ruby></li></ul><h3>relation</h3><p>即常说的<ruby data-notation="Table">表<rp>(</rp>,<rt>Table</rt>,<rp>)</rp></ruby></p><h3><ruby data-notation="Tuple">元组<rp>(</rp>,<rt>Tuple</rt>,<rp>)</rp></ruby></h3><p>即表中的一行数据</p><h3><ruby data-notation="Primary Keys">主键<rp>(</rp>,<rt>Primary Keys</rt>,<rp>)</rp></ruby></h3><p>表中对每一个元组的<strong>唯一</strong>标识符</p><h3><ruby data-notation="Foreign Keys">外键<rp>(</rp>,<rt>Foreign Keys</rt>,<rp>)</rp></ruby></h3><p>在一个表中用于关联另一个表中数据的键</p><h2>Relational Algebra</h2><p>Relational algebra operators:</p><ul><li>Select</li><li>Projection</li><li>Union</li><li>Intersection</li><li>Difference</li><li>Product</li><li>Join</li></ul><p>Extra operators:</p><ul><li>Rename</li><li>Assignment</li><li>Duplicate Elimination</li><li>Aggregation</li><li>Sorting</li><li>Division</li></ul><p>Each operator takes one or more relations as inputs and outputs a new relation.</p><div class="table"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>Select</td><td><ruby data-notation="Choose a subset of the tuples from a relation that satisfies a selection predicate">从表中根据一些特定条件选出一个子集<rp>(</rp>,<rt>Choose a subset of the tuples from a relation that satisfies a selection predicate</rt>,<rp>)</rp></ruby></td></tr><tr><td>Projection</td><td><ruby data-notation="Generate a relation with tuples that contains only the specified attributes">从表中选出特定几个列，组成新表<rp>(</rp>,<rt>Generate a relation with tuples that contains only the specified attributes</rt>,<rp>)</rp></ruby></td></tr><tr><td>Union</td><td><ruby data-notation="Generate a relation that contains all tuples that appear in either only one or both input relations">选取数个表，返回其合并后产生的新表<rp>(</rp>,<rt>Generate a relation that contains all tuples that appear in either only one or both input relations</rt>,<rp>)</rp></ruby></td></tr><tr><td>Intersection</td><td><ruby data-notation="Generate a relation that contains only the tuples that appear in both of the input relations.">选取数个表，返回其取交集产生的新表<rp>(</rp>,<rt>Generate a relation that contains only the tuples that appear in both of the input relations.</rt>,<rp>)</rp></ruby></td></tr><tr><td>Difference</td><td><ruby data-notation="Generate a relation that contains only the tuples that appear in the first and not the second of the input relations.">对两个表，返回在第一个表中，第二个表中没有出现的元组组成的新表<rp>(</rp>,<rt>Generate a relation that contains only the tuples that appear in the first and not the second of the input relations.</rt>,<rp>)</rp></ruby></td></tr><tr><td>Product</td><td><ruby data-notation="Generate a relation that contains all possible combinations of tuples from the input relations">返回由两个表中所有元组的所有组合组成的新表<rp>(</rp>,<rt>Generate a relation that contains all possible combinations of tuples from the input relations</rt>,<rp>)</rp></ruby></td></tr><tr><td>Join</td><td><ruby data-notation="Generate a relation that contains all tuples that are a combination of two tuples (one from each input relation) with a common value(s) for one or more attributes">通过另一个表的数据作为条件来查询一个表中的数据<rp>(</rp>,<rt>Generate a relation that contains all tuples that are a combination of two tuples (one from each input relation) with a common value(s) for one or more attributes</rt>,<rp>)</rp></ruby>tes)</td></tr></tbody></table></div>
<p><a href="https://bhznjns.github.io/#static/学习笔记/数据库系统-CMU-15445/Introduction.md">
    点此查看原文
</a></p>
</article>
<footer><p><span class="dim"><a href="user/count.html">字数统计</a> | Powered by <a href="https://github.com/BHznJNs/markdown-blog" target="_blank">MarkdownBlog</a></span></p></footer>
</body>
</html>